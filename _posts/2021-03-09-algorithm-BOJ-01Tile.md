---
published: false
title: '[백준] 1904번 - 01타일'
layout: post
subtitle: 'BOJ 1904, 01타일'
categories: algorithm
tags: boj problems
comments: true
---
# **문제**
---
> [`https://www.acmicpc.net/problem/1904`](https://www.acmicpc.net/problem/1904)

## **문제 설명 및 풀이**
---
매우 뻔한 dp문제이다. 피보나치수열과 같은 패턴이 제일 흔한 dp문제인것같다. 대충 몇개 구해보고 피보나치수열인 것을 확인한 후 코드로 옮기지 말고, 왜 그런 패턴을 보이는지를 꼭 알고 넘어가도록 하자.  
 먼저 길이가 N인 수를 만들어보자. 사용할 수 있는 숫자 카드는 00과 1이므로 이전 단계에서 만든 수에다가 00을 붙이거나, 1을 붙여서 만든다는 얘기가 된다. 하지만 00은 길이가 2이기 때문에 N-1번째에서는 붙일 수가 없으므로 N-2번째에서 00을 붙여서 만들어야 한다. 결론적으로, N-2번째에서 00을 붙여서 만드는 경우의 수와 N-1번째에서 1을 붙여 만들 수 있는 경우의 합이길이가 N인 수를 만드는 경우의 수이다. 참고로 N-2번째에서 11을 붙여 만드는 경우를 배제하는 이유는 N-1번째에서 1을 붙여 만드는 경우에 포함되기 때문이다. N이 4인 경우를 예시로 살펴보자.  
우선, N-2(=2)와 N-1(=3)을 먼저 구한다.  
N=2인 경우 -> 00, 11  
N=3인 경우 -> 001, 100, 111이다.

먼저 N-2인 경우(N=2)에 00을 붙여 나올 수 있는 수는 0000, 0011, 1001, 1100이고, 1 두개를 붙여 만들 수 있는 수는 1100, 0011, 1111으로 전부 5개가 된다.  
이번엔 N-1인 경우(N=3)에 1을 붙여 만들 수 있는 수를 구해보면 1001, 1100, 1111, 0011으로 총 4개가 된다.  
여기서 중복들을 모두 제거해 보면 진짜 값은 5개가 된다. 중복을 제거하기가 까다로울 수 있지만 일정한 규칙을 정하면 구하기 더 편하다. N-2에선 00만 붙이고, N-1에선 1만 붙여 만드는데, 모두 맨 뒤에 붙여서 만드는 것이다.  
N-2의 맨 뒤에 00추가 -> 0000, 1100  
N-1의 맨 뒤에 1 추가-> 0011, 1100, 1111  
이렇게 총 5개로 중복을 제거하고 구할 수 있다.  

## **코드**
---

```c++
#include <iostream>

using namespace std;

int n;
int arr[1000001];

int main()
{
    arr[1] = 1, arr[2] = 2;
    for (int i = 3; i <= 1000000; i++)
        arr[i] = (arr[i - 2] + arr[i - 1])%15746;
    cin >> n;
    cout << arr[n]%15746;
    return 0;
}
```
