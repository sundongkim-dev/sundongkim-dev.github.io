---
published: false
layout: post
subtitle: 'BOJ 15649, N & M(1)'
categories: algorithm
tags: BOJ
comments: true
title: '[백준] 15649 - N과 M'
---
# **문제**
---
> [`https://www.acmicpc.net/problem/15649`](https://www.acmicpc.net/problem/15649)

## **문제 설명 및 풀이**
---
`백트래킹`의 전형적인 문제 중 하나이다. 백트래킹이란 쉽게 이야기하자면 말 그대로 `(방금 왔던 길을) 되짚어 가는 것`을 말한다. 조금 어렵게 설명한다면, `현재 상태에서 가능한 모든 후보들을 살펴보며 탐색하는 알고리즘`을 말한다.  
이 문제에서는 `bfs`라는 탐색법을 사용하면 쉽게 풀 수 있다. 기본적으로 백트래킹은 dfs, bfs를 굉장히 많이 사용한다. 위 알고리즘들은 추후에 정리하여 포스팅하도록 하겠다.  
처음 이 문제를 풀 때, 단번에 풀이를 알기란 쉽지가 않다. 고도의 구현력이 필요하며, 코드를 봐도 이해하는 데 시간이 많이 걸릴지도 모른다. 그런 사람들은 그림을 그려가며 천천히 재귀 함수를 공부하길 바란다.  
아래의 코드 형태를 잘 외워두길 바란다. 처음에는 외우고 이후 비슷한 유형의 문제들을 풀다 보면 서서히 감이 올 것이다. 필자도 처음 이런 풀이를 보았을 때 충격을 받았던 기억이 난다. 재귀는 코딩이 간단하면서도 굉장히 강력한 도구임을 알게 된다.
구현은 다음과 같다. 재귀를 하면서 이미 방문한 노드는 다음 노드를 탐색해야 하는데, 이를 검사하기 위해 visited라는 boolean 배열을 만들고, 탐색과정에서 정답을 입력해 둘 ans 배열을 만들어 둔다. cnt를 증가시켜 M과 같아지면 더 이상 함수를 호출하지 않고 정답 배열을 출력해 주고 return 해준다. `재귀에서 base condition을 설정하는 것은 매우 중요`하다. 자칫 잘못하면 무한 루프에 빠질 수 있기 때문이다. 같지 않다면, 탐색하면서 이미 탐색했다면 넘어가고 그렇지 않다면 ans 배열에 추가하며 재귀가 깊어지는 것을 알 수 있다.  

더 자세한 설명을 원하는 사람들은 아래 사이트를 방문하길 바란다. 다른 사람들의 코드 리뷰를 하던 중 알게된 분인데, BaaaaaaaarkingDog님의 글이다. 정말 설명을 기가 막히게 잘한 글이다. 
> [더 자세한 설명을 원한다면](https://blog.encrypted.gg/945)

## **코드**
---
<script src="https://gist.github.com/sundongkim-dev/88b7235cb52cae3097e56b9356497012.js"></script>
