---
published: true
title: '[컴퓨터 네트워크] Computer Networks and the Internet'
layout: post
subtitle: 'csReview Computer Network'
categories: csReview
tags: ComputerNetwork
comments: true
---

# 컴퓨터 네트워크 복습
요즘 알고리즘 문제 풀기나 만들고 싶은 program만들기..토이 프로젝트 등만 하다가 교수님의 조언을 듣고 CS의 코어 과목들을 다시 복습, 정리해보려고 한다. 컴퓨터 네트워크를 시작으로 자료구조, 운영체제, db 등을 정리해나갈 생각이다. 3일에 한 챕터를 정리하는 것을 목표로 시작해보겠다. 본문은 James F. Kurose와 Keith W. Ross의 Computer Networking A Top-Down Approach를 바탕으로 정리한 내용이다.  
- 목차  
 [1. Computer Networks and the Internet](#1-computer-networks-and-the-internet)
  + [1.1 What is the Internet](#11-what-is-the-internet)
  + [1.2 Network edge](#12-network-edge)
  + [1.3 Network core](#13-network-core)
  + [1.4 Delay, loss, throughput in networks](#14-delay-loss-throughput-in-networks)
  + [1.5 Protocol layers, service models](#15-protocol-layers-service-models)
  + [1.6 Networks under attack: Security](#16-networks-under-attack-security)

---
## 1. Computer Networks and the Internet
### 1.1 What is the Internet
▷ Internet = network of networks(Interconnected ISPs)  
#### 1.1.1 Nuts and bolts view(인터넷을 구성하는 기본적인 HW와 SW 요소를 기술)  
모든 장치(Billions of connected computing devices)이자 Hosts이자 **End systems**은 **communication link**와 **packet switch**의 네트워크로 연결된다. Communication link는 도로, packet은 트럭, packet switch는 교차로라고 할 수 있겠다.  
* **Communication link**: 동축케이블, 구리선, 광케이블, 라디오 스펙트럼 등 물리 매체  
* **Packet**: 데이터를 세그먼트로 나누고 각각 헤더를 붙인 정보 패키지  
* **Packet switch**: 패킷을 받아서 목적지로 전달
  * 패킷 스위치 중 가장 널리 사용되는 두 가지 종류, 둘 다 최종 목적지 방향으로 패킷을 전달함  
    1. **Router**: network core에서 사용됨  
    2. **Link-layer switch**: 엑세스 네트워크에서 사용됨  
* **Route**(path): 패킷이 송신 종단 시스템에서 수신 종단 시스템에 도달하는 동안 거쳐 온 일련의 통신 링크와 패킷 스위치들  
* **ISP(Internet Service Provider)**: packet switch와 communication link로 이루어진 네트워크이다. End systems가 이것을 통해서 인터넷에 접속하며 CP(Content Provider)에게 인터넷 접속을 제공한다. 또한 종단 시스템을 서로 연결하는 것이기에 ISP들도 서로 연결되어야만 한다.  
* **Protocol**: 인터넷에서 정보 송수신을 제어한다. **TCP, IP, HTTP, Skype, 802.11** 등이 있으며 추후에 살펴보도록 하자.

---
#### 1.1.2 Service view(분산 app에 서비스를 제공하는 네트워킹 인프라 구조 관점에서 기술)  
예를 들자면 Web, VoIP(Voice over IP), email, games, e-commerce, social nets 등이 있다. Internet Application은 end system에서 수행된다.(Network core에 있는 packet switch에서 수행 되지 않음)  
**Socket interface**: 송신 프로그램이 따라야 하는 규칙의 집합(Postal service와 유사)

---
#### 1.1.3 What’s a protocol?
 **Protocol**: **둘 이상의 통신 개체** 간에 교환되는 **메시지 포맷**과 **순서**뿐 아니라, **메시지의 송수신과 다른 이벤트에 따른 행동**들을 **정의**한다.  

---
### 1.2 Network edge  
수많은 Hosts(End Systems)를 **Client**와 **Server**로 구분
#### 1.2.1 Access networks  
**Access networks**: 각 종단 시스템의 경로에 있는 첫 번째 router에 연결하는 네트워크(edge router)를 말한다. 추후에 자세히 다루겠다.  
#### 1.2.2 physical media  
그렇게 중요하다고 생각되지 않으니, 필요하다면 서술하도록 하겠다.  

---
### 1.3 Network core
▷ 인터넷의 종단 시스템을 연결하는 패킷 스위치들과 링크들의 연결망(mesh)

---
#### 1.3.1 Packet switching
송신 종단 시스템에서 목적지 종단 시스템으로 메시지를 보내기 위해, 송신 시스템은 **긴 메시지를 패킷으로 분할**하고 통신 링크와 패킷 스위치를 거치게 되는데, 패킷은 **링크의 최대 전송 속도와 같은 속도로 각각의 통신 링크상에서 전송된다.** 즉, R bits/sec의 속도로 L bits를 송신한다면 전송하는데 걸리는 시간은 L/R초이다.  
* **저장 후 전달 전송(Store-and-forward transmission)**
▷ 스위치가 출력 링크로 패킷의 **첫 비트를 전송하기 전**에 **전체 패킷을 받아야 함**을 의미한다. 다시 말해, 패킷의 비트를 먼저 **저장(Store)**한 후 라우터가 모든 비트를 수신한 후에만 출력 링크로 그 패킷을 **전송(Forward)**하기 시작한다.
* **큐잉 지연과 패킷 손실(Queueing delay & Packet loss)**    
  1. 각 패킷 스위치는 접속된 여러 개의 링크를 갖고 있는데 각 링크에 대해 패킷 스위치는 **출력 버퍼**를 갖는다. 도착하는 패킷이 한 링크로 전송될 필요가 있는데 그 링크가 다른 패킷을 전송하고 있다면, 도착하는 패킷은 출력 버퍼에서 대기해야 하며 이를 **큐잉 지연**이라고 한다.  
  2. 버퍼 공간의 **크기가 유한**하기 때문에 도착하는 패킷은 버퍼가 전송을 위해 대기 중인 다른 패킷들로 꽉 차있는 경우가 발생할 수 있다. 이 때 패킷 손실이 발생한다. **정책에 따라** 도착하는 패킷 혹은 이미 큐에 대기 중인 **패킷을 폐기(drop)** 한다.
* **전달 테이블(Forwarding table)과 라우팅 프로토콜**  
  **Forwarding table**: 각 라우터가 목적지 주소를 라우터의 출력 링크로 맵핑한 테이블을 말한다.
이 때, 전달 테이블을 설정하기 위해 이용되는 여러 특별한 **라우팅 프로토콜**이 있다. 예를 들어, 라우팅 프로토콜은 각 라우터로부터 각 목적지까지의 최단 경로를 결정하고 라우터에 전달 테이블을 설정하는 데 이 최단 경로 결과를 이용한다.  
cf) 인터넷에서 패킷이 실제로 거쳐 가는 종단간의 경로를 실제로 보고 싶다면, **Traceroute** 프로그램 써보시길..!!

---
#### 1.3.2 Circuit switching
링크와 스위치의 네트워크를 통해 데이터를 이동시키는 방식에는 회선교환과 패킷교환이라는 두 가지 기본 방식이 있는데, 앞선 1.3.1에선 패킷교환에 대해 살펴보았다.   
종단 시스템 간에 통신을 제공하기 위해 **경로에 필요한 자원(버퍼, 링크 전송률)** 은 통신 세션 동안에 **확보 또는 예약**된다. 반면, 패킷 교환은 링크 자원을 예약하지 않고 네트워크로 보내지기에 일정 시간 내에 전달하는 것을 보장할 수 없다.
* **FDM**(Frequency-division multiplexing,주파수-분할 다중화)
: 각 회선은 지속적으로 대역폭의 일부를 얻는다.
* **TDM**(Time-division multiplexing,시-분할 다중화)
: 각 회선은 짧은 시간(슬롯) 동안 주기적으로 전체 대역폭을 얻는다. 전송시간은 링크 수와 무관하다.  

**<패킷 교환 vs. 회선 교환>**
* 패킷 교환 옹호자
  1. 전송 용량의 공유에서 더 효율적
  2. 더 간단하고 효율적이며 구현 비용이 적음
  3. 패킷을 생성하는 다른 사용자가 없는 경우, 다중화가 요구되지 않고 링크가 가득 찰 때까지 패킷을 계속 보낼 수 있음
* 회선 교환 옹호자
  1. 가변적이고 예측할 수 없는 종단간의 지연 때문에 실시간 서비스(전화통화, 비디오 회의 통화 등)는 회선 교환을 써야 함
  2. 요구에 관계없이 미리 전송 링크의 사용을 할당함

---
#### 1.3.3 Network of networks
모든 종단 시스템이 서로에게 패킷을 보내려면 접속 ISP들이 서로 연결되어야만 한다. 직접 서로 다른 ISP와 연결하는 것은 너무 많은 비용[= O(n<sup>2</sup>)]을 발생한다. 별적인 통신링크를 유지해야 하기 때문이다.  
1. **네트워크 구조 1**: 모든 접속 ISP들을 하나의 global transit ISP와 연결한다. 이 때, 접속 ISP가 글로벌 ISP에게 요금을 지불하기에 고객-제공자 관계이다.  
2. **네트워크 구조 2**: 다중의 global transit ISP가 생겨나 가격,서비스를 비교하며 경쟁한다. 그러나, 글로벌 ISP끼리들은 반드시 연결되어야 한다.  
3. **네트워크 구조 3**: 접속 ISP > 지방 ISP > 국가 ISP > tier-1 ISP로 이루어진 다중 계층구조
4. **네트워크 구조 4**: 네트워크 구조3에 (PoP + 멀티홈 + 피어링 + IXP)를 더한 구조  
    * PoP(Points Of Presence): 제공자의 네트워크 내에 있는 라우터 그룹  
    * 멀티홈: 모든 ISP는 둘 이상의 제공자 ISP에 연결하도록 선택할 수 있다  
    * 피어링: 같은 계층에 있는 가까운 ISP들이 서로 직접 연결하여 상위 계층 ISP를 통하지 않고 직접 송수신하며 서로 요금을 지불하지 않는다.  
    * IXP: 다중의 ISP들이 서로 피어링할 수 있는 만남의 장소  
5. **네트워크 구조 5**: 네트워크 구조4 + Content-provider network(ex..google,MS,Akamai)

---
### 1.4 Delay, loss, throughput in networks

#### 1.4.1 패킷 교환과 네트워크에서의 지연
1. **노드 처리 지연**: 패킷 헤더를 조사하고 어디로 보낼지를 결정하는 시간
2. **큐잉 지연**: 패킷이 큐에서 링크로 전송되기를 기다리는 시간
3. **전송 지연**: 패킷의 길이가 R비트이고 링크의 전송률이 L이라면 L/R
4. **전파 지연**: 링크의 처음부터 목적지 라우터 까지의 전파에 필요한 시간

---
#### 1.4.2 큐잉 지연과 패킷 손실
다른 종류의 지연들과 달리 **큐잉 지연**은 패킷마다 다를 수 있다.
> 큐의 공간은 무한하다고 하자. 또,  
a: 패킷이 큐에 도착하는 평균율(단위=패킷/초)  
R: 전송률, 비트가 큐에서 밀려나는 비율(비트/초)  
L: 모든 패킷의 비트 수가 동일한 L이라고 하자.  
그렇다면, 비트가 큐에 도착하는 평균율은 La(비트/초)이다.  
트래픽 강도(La/R)는 큐잉 지연의 정도 측정에 매우 중요한데, La/R > 1이라면 큐는 끝없이 증가하고 큐잉 지연은 무한대에 도달하며 La/R <= 1이라면 도착 트래픽의 특성에 따른다.

**도착 트래픽의 특성**
1. 패킷이 **주기적**(L/R초마다)으로 도착한다면 큐잉 지연은 없을 것이다.
2. 패킷이 **몰려서** 도착한다면 n번째 전송된 패킷은 (n-1)L/R초의 큐잉 지연이 발생한다.  

**패킷 손실**
실제로는 큐가 무한대 패킷을 가질 수 없기에 트래픽 강도(La/R)가 1에 접근함에 따라 지연이 무한대가 되지 않고 큐가 패킷으로 꽉 차게된다. 결국 라우터는 패킷을 drop하고 잃어버리게 된다.  

#### 1.4.3 종단간 지연
종단간의 N-1개의 라우터가 있고, 큐잉 지연을 무시할 수 있다면 종단간의 지연은 `N(처리지연+전송지연(L/R)+전파지연)`이라 할 수 있다.  
**Traceroute**: 출발지에서 목적지까지 패킷이 흘러간 경로를 알 수 있게 한다.
1. TTL(Time-To-Live)을 1로 패킷을 전송한다.
2. TTL이 0이된 바로 다음 라우터는 ICMP error 메세지를 돌려준다. (경로에 있는 첫번째 라우터 IP를 기록)
3. TTL을 2로 패킷을 전송한다.
4. TTL이 0이된 경로중 2번째에 있는 라우터는 ICMP error 메세지를 돌려준다. (경로에 있는 두번째 라우터 IP 알아냄!)
5. 위와 같은 방식으로 도착할 때 까지 모든 TTL을 늘려가며 전송한다.
6. 목적지의 ICMP 메세지를 받으면, 라우팅 경로의 모든 IP를 알 수 있다.

cf) 미디어 패킷화 지연(주로 VoIP에서 사용)은 추후에 알아보자!

#### 1.4.4 컴퓨터 네트워크에서의 처리율(Throughput)
F비트 파일을 서버에서 클라이언트로 전송하는 데 걸리는 시간(근삿값) = F/ min[Rc,Rs]  
처리율은 **링크의 전송속도**에 의존하며, 경로 상에서 최소 전송속도(=min[R1,R2,...])로 근사치화 할 수 있다.  
또한, 처리율은 **간섭하는 트래픽(하나의 링크를 공유)**에도 의존한다.

---
### 1.5 Protocol layers, service models
#### 1.5.1 계층구조
**인터넷 프로토콜 스택(Internet Protocol Stack)**: 애플리케이션-트랜스포트-네트워크-링크-물리  
**OSI 참조 모델**(The **O**pen **S**ystem **I**nterconnection model): 애플리케이션-프레젠테이션-세션-트랜스포트-네트워크-링크-물리  
1. **애플리케이션 계층**: **네트워크 app**과 **app 계층 프로토콜**이 있는 곳, HTTP(웹 문서 요청과 전송), SMTP(전자메일 전송) 및 FTP(종단 시스템 간의 파일 전송) 등의 프로토콜을 포함한다. 애플리케이션 계층에서의 정보 패킷을 메시지(message)라고 한다.  
2. **트랜스포트 계층**: 클라이언트와 서버 간에 **app 계층 메시지를 전송**하는 서비스를 제공한다.
트랜스포트 계층에서의 패킷은 세그먼트(segment)라고 한다. 인터넷에는 **두 가지** 트랜스포트 프로토콜이 있다.
  1. **TCP**: 연결지향형 서비스 제공 = 전달 보장, 흐름제어(송/수신자의 속도 일치), 혼잡제어 기능 제공
  2. **UDP**: 비연결형 서비스 제공 = 신뢰성, 흐름제어, 혼잡제어 X  
3. **네트워크 계층**: 한 호스트에서 다른 호스트로 **데이터그램**을 라우팅하는 책임을 진다. 목적지 호스트의 트랜스포트 계층으로 세그먼트를 운반하는 서비스 제공한다. IP 데이터그램의 필드를 정의하며 종단 시스템과 라우터가 이 필드에 어떻게 동작하는지를 정의하는 프로토콜(IP 프로토콜)을 갖고 있다. **오직 하나의 IP프로토콜**이 있고, 네트워크 계층을 가진 모든 인터넷 요소는 IP프로토콜을 수행해야만 한다. 또한, 데이터그램이 이동하는 경로를 결정하는 라우팅 프로토콜을 포함한다.
4. **링크 계층**: 네트워크 계층에서 받은 데이터그램을 경로상의 다음 노드에 전달하며 다음 노드에서 링크 계층은 그 데이터그램을 상위 네트워크 계층으로 보낸다. 데이터그램은 경로상의 **서로 다른 링크에서 다른 링크 계층 프로토콜에 의해 처리**될 수 있다. 링크 계층 프로토콜의 예시로는 **이더넷, 와이파이, 케이블 네트워크의 DOCSIS 프로토콜, PPP**등이 있다. 링크 계층의 패킷은 **프레임(frame)**이라고 한다.
5. **물리 계층**: 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동하는 것, 물리 계층 프로토콜은 링크에 의존하고 링크의 실제 전송 매체에 의존

1-1)**프레젠테이션 계층**: 통신하는 app들이 교환되는 데이터의 의미를 해석하는 서비스 제공한다. 데이터 기술(저장되는 내부 포맷 걱정하지 않게 해줌)뿐만 아니라 데이터 압축과 데이터 암호화를 포함한다.  
1-2)**세션 계층**: 데이터 교환의 경계와 동기화를 제공(checking point, recovery of data exchange)

---
#### 1.5.2 Encapsulation(캡슐화)
![그림 1](https://sundongkim-dev.github.io/assets/img/network_encapsulation.jpg)  
애플리케이션 계층 **메시지**는 트랜스포트 계층으로 보내지고, 트랜스포트 계층에서 헤더를 붙여 **세그먼트**를 구성한다. 이 세그먼트는 애플리케이션 계층 메시지를 캡슐화한다. 추가된 정보로는 수신자가 결정하는 오류 검출 비트를 포함한다. 그다음, 세그먼트를 네트워크 계층으로 보내 헤더 정보를 추가하여 네트워크 계층 **다이어그램**을 만든다. 이는 링크 계층으로 전달되어 **프레임**을 만든다. 각 계층에서 패킷은 **헤더 필드**와 **페이로드 필드(Payload field)**라는 두 가지 형태의 필드를 갖는다. 전송 이후에는 캡슐화의 반대과정이 이루어지며 수신자가 정보를 확인하게 되는 것이다.

---
### 1.6 Networks under attack: Security
**인터넷을 통해 맬웨어(악성코드) 침투 가능**
1. 봇넷(Botnet): 면역되지 않은 장치들로 구성된 네트워크, DDoS공격 당할 수 있음.
2. 스파이웨어 맬웨어: keystroke 등을 기록할 수 있어서 해킹 가능
3. 맬웨어는 자기복제를 함 = 호스트의 엔트리를 타고 들어가서 다른 호스트에게도 영향을 끼침
4. 바이러스: 사용자와의 상호작용이 필요한 맬웨어
5. 웜: 사용자의 직접적인 상호작용 없이 장치에 침투하는 맬웨어
6. **DoS(Denial of Service)**: 네트워크, 호스트 혹은 다른 기반구조의 요소들을 정상적인 사용자들이 사용할 수 없게 하는 것  
  1. 취약성 공격(Vulnerability attack) = 공격받기 쉬운 app이나 OS에 메시지를 보냄
  2. 대역폭 플러딩(Bandwidth flooding) = 수많은 패킷을 보내서 동작 못하게 함
  3. 연결 플러딩(Connection flooding) = Half or Fully open된 TCP 연결을 설정 = 가짜 연결을 처리
7. **패킷 스니퍼(Packet sniffer)**: 지나가는 모든 패킷의 사본을 기록하는 수동적인 수신자  
▷ 유선 환경에서도 배치 될 수 있음  
▷ 수동적(채널에 패킷을 삽입하지 않음)이기에 탐지하기 어려움
▷ 가장 좋은 방어는 암호화를 포함하는 것
8. **IP spoofing**: 거짓의 출발지 주소를 가진 패킷을 인터넷으로 보내는 능력  
How to solve? ▷ 종단 인증(End-point authentication), 추후에 살펴보자!
