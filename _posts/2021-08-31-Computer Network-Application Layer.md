---
published: false
title: '[컴퓨터 네트워크] Application Layer'
layout: post
subtitle: 'csReview Computer Network'
categories: csReview
tags: ComputerNetwork
comments: true
---

# 컴퓨터 네트워크 복습(2)
3일에 한 챕터를 정리하려 했으나, 연습문제들도 다 풀어보고 실습도 하느라 최소 일주일은 잡아야 할 것 같다... 학기가 시작되면 시간 배분을 어떻게 해야할 지 고민이다. 본문은 James F. Kurose와 Keith W. Ross의 Computer Networking A Top-Down Approach를 바탕으로 정리한 내용이다.  
- 목차  
 [1. Computer Networks and the Internet](#1-computer-networks-and-the-internet)
  + [1.1 What is the Internet](#11-what-is-the-internet)
  + [1.2 Network edge](#12-network-edge)
  + [1.3 Network core](#13-network-core)
  + [1.4 Delay, loss, throughput in networks](#14-delay-loss-throughput-in-networks)
  + [1.5 Protocol layers, service models](#15-protocol-layers-service-models)
  + [1.6 Networks under attack: Security](#16-networks-under-attack-security)

---
## 2. Application Layer

### 2.1 Principles of network applications
네트워크 애플리케이션을 위한 통신은 종단 시스템 간의 애플리케이션 계층에서 발생한다.

#### 2.1.1 네트워크 애플리케이션의 구조
1. 클라이언트-서버 구조 ex) 웹,파일 전송,원격 로그인,전자메일  
 + 서버: 항상 켜져 있는 호스트로 많은 클라이언트들로부터 요청을 받으며 고정 IP주소를 갖는다.
 + 클라이언트: 서로 직접적으로 통신하지 않는다.  

 cf) 데이터 센터: 많은 수의 호스트를 갖춘 강력한 가상의 서버를 생성

2. P2P(Peer-to-peer) 구조: 항상 켜져 있는 서버에 최소로 의존(혹은 전혀 의존하지 않음)한다. Peer라는 간헐적으로 연결된 호스트 쌍이 직접 통신하도록 하며, 다음의 두 가지 특성을 지닌다.   
 **자가 확장성(self-scalability)**: 비록 새로 참여한 피어들이 파일을 요구함으로써 작업 부하를 만들어내지만 그들은 또한 파일을 다른 피어들에게 분배함으로써 그 시스템에 서비스 능력을 추가한다.  
 **비용 효율적**: 서버 기반구조와 대역폭을 요구하지 않기 때문이다.  
 ex) 비트토렌트, 쉰레이, 스카이프

#### 2.1.2 프로세스 간 통신
**프로세스**: 종단 시스템에서 실행되는 프로그램이며, 2개의 다른 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신한다.  
**클라이언트 프로세스**: 두 프로세스 간의 통신 세션에서 통신을 초기화하는 프로세스  
**서버 프로세스**: 세션을 시작하기 위해 접속을 기다리는 프로세스  
P2P의 경우 프로세스는 파일을 올리고 또한 내려 받을 수 있다.  

**프로세스(집)**는 **소켓(출입구)**을 통해 네트워크로 메시지를 보내고 받는다.  
**소켓**: 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스, 애플리케이션과 네트워크 사이의 API(Application programming interface)  
app개발자는 소켓의 app 계층에 대한 모든 통제권을 갖지만, 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다. 유일하게 두 가지인데 다음과 같다.  
1. 트랜스포트 프로토콜의 선택
2. 최대 버퍼와 최대 세그먼트 크기와 같은 약간의 트랜스포트 계층 매개변수의 설정

**프로세스 주소 배정**
수신 프로세스를 식별하기 위해서는 다음 두 가지 정보가 필요하다.
1. 호스트의 주소(32bit의 IP주소로 식별)
2. 목적지 호스트 내의 수신 프로세스를 명시하는 식별자(목적지 포트 번호로 식별)  
  ex) HTTP server:80,mail server:25

#### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스
1. **신뢰적 데이터 전송**  
 ▷ 몇몇 app들은 100% 신뢰적 전송을 보장해야 한다  
 ▷ 송신 프로세스는 데이터를 소켓으로 보내고 그 데이터가 오류 없이 수신 프로세스에 도착  
 ▷ 손실 허용 app의 예시: 실시간 오디오/비디오 혹은 저장 오디오/비디오와 같은 멀티미디어 app  
2. **처리량**  
 ▷ 대역폭 민감 애플리케이션: 처리율 요구 사항을 갖는 app  
 ▷ 탄력적 애플리케이션: 가용한 처리율을 많으면 많은 대로 적으면 적은 대로 이용
3. **시간**  
 ▷ 송신자가 소켓으로 내보내는 모든 비트가 수신자의 소켓에 일정 시간 내에 도착하도록 함  
 ▷ 인터넷 전화, 멀티플레이어 게임, 원격회의 같은 실시간 상호작용 app에서 매력적이며 낮은 지연 요구됨
4. **보안**  
 ▷ 송신 호스트에서 트랜스포트 프로토콜은 송신 프로세스가 전송하는 모든 데이터를 암호화할 수 있고 수신 호스트에서 트랜스포트 프로토콜은 그 데이터를 수신 프로세스로 전달하기 전에 데이터의 암호를 해독할 수 있다(비밀성 + 데이터 무결성 + 종단 인증)


#### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

**TCP(Transmission Control Protocol)**: 연결지향형 서비스 ▷ 핸드셰이킹 과정 = app계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 함 = 패킷이 곧 도달할 것이니 준비하라고 알림
▷ TCP 연결이 두 프로세스의 소켓 사이에 존재 ▷ Full-duplex 연결 = 서로에게 동시에 메시지
▷ app이 메시지 전송을 마치면 연결을 끊어야 함
신뢰적인 데이터 전송 서비스 ▷ 모든 데이터를 오류 없이 올바른 순서로 전달
혼잡제어 방식 = 네트워크가 혼잡상태에 이르면 프로세스 속도를 낮춤
<UDP>
비연결형 = 핸드셰이킹 하지 않음
비신뢰적인 데이터 전송 서비스 제공 = 심지어 순서도 뒤바뀔 수 있음
혼잡제어 방식 미포함 = UDP의 송신 측은 데이터를 원하는 속도로 하위 계층으로 보낼 수 있으나 실제 종단간 처리율은 이 속도보다 작아질 수 있음
TCP가 보안서비스(암호화,데이터 무결성,종단 인증)를 제공하려고 app계층에서 SSL을 통해 강화
APP이 SSL을 이용하고 한다면, app의 클라이언트와 서버 측 모두에 SSL 코드를 포함해야 함
APP이 SSL을 사용할 때 송신 프로세스는 평문 데이터를 SSL 소켓에게 전달함
▷송신 호스트에 있는 SSL은 데이터를 암호화하고 암호화된 데이터를 TCP소켓으로 전달
▷수신 소켓은 암호화된 데이터를 SSL로 전달하고, 이 SSL은 데이터의 암호를 품
▷SSL은 SSL소켓을 통해 평문 데이터를 수신 프로세스로 전달함
시간 민감 애플리케이션들에게 만족스런 서비스를 제공할 수 있긴 하나 보장할 순 없음




인터넷 전화의 경우 UDP상에서 수행되기에 혼잡제어 방식과 패킷 오버헤드를 회피할 수 있음
2.1.5 애플리케이션 계층 프로토콜
①교환 메시지 타입(요청 & 응답 메시지)
②여러 메시지 타입의 문법(메시지 내부의 필드와 필드 간의 구별 방법)
③필드의 의미(필드에 있는 정보의 의미)
④언제 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
▷ RFC에 명시되어 있음,
Open protocols = RFC에 명시되어 있으며, allows for interoperability, HTTP, SMTP
Proprietary protocols = Skype
2.2.1 HTTP(HyperText Transfer Protocol)
▷웹의 애플리케이션 계층 프로토콜
웹 페이지는 객체(HTML파일,JPEG이미지,GIF이미지,자바애플릿,오디오클립)들로 구성됨
대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성
기본 HTML파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조
ex) www.someSchool.edu/someDepartment/picture.gif





서버가 클라이언트에게 요청 파일을 보낼 때, 서버는 클라이언트에 관한 어떠한
상태 정보도 저장하지 않음 = stateless protocol
2.2.2 비지속 연결과 지속 연결
①비지속 연결
서버가 객체를 보낸 후에 각 TCP 연결이 끊어짐
각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송하기에 객체 개수만큼의 TCP 연결이 만들어 짐 //의도적으로 동시성 정도를 조절 가능













②지속 연결
각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 함
▷TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 함
각 개체는 2 RTT를 필요로 함
서버는 응답을 보낸 후에 TCP 연결을 그대로 유지
같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내짐
전체 웹페이지를 하나의 지속 TCP 연결을 통해 보낼 수 있음
객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있음







2.2.3 HTTP 메시지 포맷
<HTTP 요청 메시지>
GET/somedir/page.html HTTP/1.1    ▷request line
Host: www.someschool.edu          ▷header line
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr











Post method = HTTP 클라이언트는 사용자가 폼(검색엔진에 검색단어)을 채워 넣을 때 사용
            ▷ entity body는 사용자가 폼 필드에 입력한 것을 포함
URL method = GET방식을 사용하고 요청된 URL의 입력 데이터(폼 필드들)를 전송
HEAD method = 요청을 받으면 HTTP 메시지로 응답하지만 요청 객체는 보내지 않음
              ▷디버깅을 위해 많이 사용
PUT method = 웹 서버에 업로드 할 객체를 필요로 하는 애플리케이션에 의해 사용
DELETE method = 사용자 또는 애플리케이션이 웹 서버에 있는 개체를 지우는 것을 허용
<HTTP 요청 메시지>
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(데이터 데이터 데이터 데이터 데이터 …)
200 OK: 요청이 성공되었고, 정보가 응답으로 보내짐
301 Moved permanently: 요청 객체가 영원히 이동됨, 새로운 URL은 응답 메시지의
 Location: 헤더에 나와 있음, 클라이언트 소프트웨어는 자동으로 새로운 URL을 추출
400 Bad Request: 서버가 요청을 이해할 수 없다는 일반 오류 코드이다
404 Not Found: 요청 문서가 서버에 존재하지 않는다
505 HTTP Version Not Supported: 요청 HTTP 프로토콜 버전을 서버가 지원하지 않음



2.2.4 사용자와 서버 간의 상호작용: 쿠키
서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 위해 웹 사이트가 사용자를 확인하는 것이 바람직한 경우에 쿠키를 사용 = 사이트가 사용자를 추적하도록 함
①HTTP 응답 메시지 쿠키 헤더 라인
②HTTP 요청 메시지 쿠키 헤더 라인
③사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
④웹 사이트의 백엔드 데이터 베이스


















2.2.5 웹 캐싱
웹 캐시(프록시 서버) = 원출처의 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체
▷자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존
①브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보냄
②웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인하고 저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 보냄
③없다면, 원출처의 서버로 TCP 연결을 설정하고 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 응답 메시지와 함께 객체를 보냄
④웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보냄
Typically, 웹 캐시는 ISP가 구입하고 설치함
①웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다
②웹 캐시는 한 기관에서 인터넷으로 접속하는 링크상의 엑세스를 대폭 줄일 수 있음
③인터넷 전체의 웹 트래픽을 실질적으로 줄임으로써 모든 애플리케이션을 위한 성능을 개선


















CDN(Content Distribution Network): 콘텐츠 전송 네트워크
인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며 트래픽을 지역화
웹 캐싱의 문제점 ▷ 캐시 내부에 있는 객체의 복사본이 새것이 아닐 수 있음
             ▷ 복사본이 클라이언트에 캐시된 이후에 웹 서버에 있는 개체가 갱신될 수 있음
조건부 GET = 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식
①GET방식을 사용
②If-Modified-Since: 헤더라인을 포함

GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보냄
HTTP/1.1 200 OK
Date: Sat, 8 Oct 2011 15:39:29
Server: Apache/1.3.0 (Unix)
Last-Modified: Wed, 7 Sep 2011 09:23:24
Content-Type: image/gif
(데이터 데이터 데이터 …)
웹 서버는 캐시에게 객체를 가진 응답 메시지를 보냄
캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게도 객체와 더불어 마지막으로 수정된 날짜를 함께 저장한다
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 7 Sep 2011 09:23:24

HTTP/1.1 304 Not Modified
Date: Sat, 15 Oct 2011 15:39:29
Server: Apache/1.3.0  
(빈 개체 몸체)
웹 서버는 클라이언트에게 이러한 응답메시지를 보냄
조건부 GET에 대한 응답으로 웹 서버가 요청된 객체를 포함해서 응답 메시지를 보내지 않음
304~ 상태 라인은 클라이언트에게 요청 객체의 캐시된 복사본을 사용하라는 것을 의미





2.3 인터넷 전자메일
①사용자 에이전트
사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해줌 ex)MS아웃룩,애플메일
메시지 작성을 끝내면, user agent가 메시지를 메일 서버로 보냄
메시지는 메일 서버의 출력 메시지 큐에 들어감
메시지를 읽고 싶다면 user agent가 메일 서버에 있는 메일박스에서 메시지를 가져옴
②메일 서버
메일 서버 안에 메일박스를 갖고 있음 = 메시지 유지 및 관리
밥의 메일 서버가 고장난 상황을 대비하여 앨리스 서버는 그 메시지를 메시지 큐에 보관하고 이후에 재시도함, 여러 날 시도해도 실패한다면 서버는 메시지 제거 후 송신자에게 통보
③SMTP(Simple Mail Transfer Protocol) = 애플리케이션 계층 프로토콜
TCP의 신뢰적인 데이터 전송 서비스를 이용
클라이언트와 서버 모두가 모든 메일 서버에서 수행됨
▷ 메일 서버가 상대 메일 서버로 메일을 보낼 때는 SMTP의 클라이언트
▷ 메일 서버가 상대 메일 서버로부터 메일을 받을 때는 SMTP 서버로 동작
2.3.1 SMTP
송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송
모든 메일 메시지의 몸체는 단순한 7비트 ASCII이어야 함
▷ 이진 멀티미디어 데이터를 보내려면 이전에 변환해야 함
▷ 전송 후에는 ASCII를 다시 원래 메시지로 변환해야만 함
▷ 그러나 HTTP는 전송 전에 멀티미디어 데이터를 ASCII로 변환하는 것을 요구하지 않음
SMTP가 메일을 보내는 데 두 메일 서버가 먼 거리에 떨어져 있더라도 중간 메일 서버를 사용X
①클라이언트는 서버 SMTP의 25번 포트로 TCP 연결 설정 이후
= Hand shaking = 송신자의 전자메일 주소와 수신자의 전자메일 주소를 제공
②클라이언트는 메시지를 보냄
③서버에 보낼 다른 메시지가 있으면 이 과정을 같은 TCP 연결상에서 반복
④그렇지 않으면 TCP에게 연결을 닫을 것을 명령
S: 220 hamburger.edu
C: HELO crepes.fr
S: 250  Hello crepes.fr, pleased to meet you
C: MAIL FROM: <alice@crepes.fr>
S: 250 alice@crepes.fr... Sender ok
C: RCPT TO: <bob@hamburger.edu>
S: 250 bob@hamburger.edu ... Recipient ok
C: DATA
S: 354 Enter mail, end with "." on a line by itself
C: Do you like ketchup?
C: How about pickles?
C: . //서버에게 메시지의 끝을 나타냄
   //ASCII에서 각 메시지는 CRLF .CRLF로 끝나며 carriage return과 line feed를 뜻함
S: 250 Message accepted for delivery
C: QUIT
S: 221 hamburger.edu closing connection
SMTP는 지속 연결을 사용
2.3.2 HTTP와의 비교
두 프로토콜 모두 한 호스트에서 다른 호스트로 파일을 전송하는 데 이용
① HTTP = 웹 서버로부터 웹 사용자 에이전트(브라우저)로 파일(객체)을 전송
   HTTP는 원칙적으로 pull 프로토콜이다
   = 누군가 서버에 정보를 올리고 사용자가 편의에 의해서 서버로부터 정보를 가져옴
   HTTP는 자신의 HTTP 응답 메시지에 각 객체를 캡슐화
② SMTP = 한 메일 서버로부터 다른 메일 서버로 파일(전자메일 메시지)을 전송
   SMTP는 원칙적으로 push 프로토콜이다
   = 송신 메일 서버가 파일을 수신 메일 서버로 보냄
   각 메시지의 몸체를 포함하여 각 메시지가 7비트 ASCII 포맷일 것을 요구
   모든 메시지의 객체를 한 메시지로 만듦
2.3.3 메일 메시지 포맷










2.3.4 메일 접속 프로토콜



①POP3: Post office Protocol, 포트 110번으로 TCP 연결을 열 때 시작
        수신자의 메일 서버로부터 수신자의 사용자 에이전트에게 메일을 전송하는데 사용
  인증 = user agent는 메일을 다운로드 하는 사용자를 인증하기 위해
         사용자 이름과 비밀번호를 보냄
         user <사용자 이름>
         pass <비밀번호>
  트랜잭션 = user agent는 메시지를 가져오고, 삭제를 위해 메시지에 표시하거나
             그 표시를 지울 수도 있으며 메일 통계를 얻을 수도 있음
            user agent는 명령을 내리고 서버는 각 명령에 대해 응답함
            +OK = 서버가 이전 명령을 잘 처리함
            -ERR = 이전 명령에 대해서 무언가 잘못되었다는 것을 나타내는 데 서버가 사용
            list = list message numbers
            retr = retrieve message by number
            dele = delete
            quit = POP3 서버는 갱신 단계로 돌아가고 메일박스에서 1,2번 메시지를 삭제
  갱신 = 클라이언트가 POP3 세션을 끝내는 quit 명령이 내려진 후에 일어남
         메일 서버는 삭제 표시된 메시지를 삭제 한다
클라이언트를 바꾼다면 이미 읽은 메시지를 또 읽을 수 없게 된다
▷다운로드 후 유지 모드 = user agent는 메시지를 다운로드 한 후 메시지를 서버에 남겨둠
user agent와 메일 서버 사이의 POP3 세션 기간 동안 POP3 서버는 여러 상태 정보를 유지
그러나 POP3 서버는 POP3 세션 사이의 상태 정보를 전달하지는 않음

②IMAP: Internet Mail Access Protocol
▷ 폴더에 각각의 메시지를 연결, 수신자는 메시지를 생성한 새 폴더로 옮기거나 읽거나 삭제 가능, 사용자가 폴더를 생성하고 하나의 폴더에서 다른 폴더로 메시지를 옮기는 명령 제공, 특정 조건에 맞는 원격 폴더를 찾는 명령도 제공
IMAP 서버는 POP3과 달리 IMAP 세션을 통해 사용자 상태 정보를 유지한다는 점을 명심
③HTTP

2.4.1 DNS가 제공하는 서비스
호스트에 대한 식별자: 호스트 네임(e.g. www.naver.com), IP 주소(32bit,어디에 위치하는지)
사람 = 호스트 네임 / 라우터 = 고정 길이의 계층 구조를 가진 IP주소
DNS(Domain Name System) = 호스트 네임을 IP주소로 변환해줌
①Host aliasing = 복잡한 호스트 네임을 가진 호스트는 하나 이상의 별명을 가질 수 있음
                 (Canonical hostname, 정식 호스트 네임) + (Alias names,별칭 호스트 네임)
②Mail server aliasing
③Load distribution = 여러 중복 서버 사이에 부하를 분산하기 위해 사용
중복 웹 서버의 경우, 여러 IP주소가 하나의 정식 호스트 네임과 연관되어 있음
DNS 데이터베이스는 이 IP주소 집합을 갖고 있음

2.4.2 DNS 동작 원리 개요
중앙 집중 방식에서 클라이언트는 모든 질의를 단일 네임 서버로 보내고, DNS 서버는 질의 클라이언트에게 직접 응답한다 => 4가지 문제점 야기
①서버의 고장
②트래픽 양
③먼 거리의 중앙 집중 데이터베이스
④유지관리 = 모든 인터넷 호스트에 대한 레코드를 유지해야 함
단일 DNS 서버에 있는 중앙 집중 database는 확장성이 전혀 없음
DNS는 분산되도록 설계됨
①분산 데이터베이스
<루트 DNS 서버> Local DNS 서버와 연결되어 있음
<TLD 서버> com, org, net, edu 같은 상위 레벨 도메인과 kr, uk, fr, ca, jp같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버, 책임 DNS 서버들에 대한 IP주소들을 제공
<책임 DNS 서버>
인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 네임을 IP주소로 매핑하는 공개적인 DNS 레코드를 제공해야 함, 기관의 책임 DNS 서버는 이 DNS 레코드를 갖고 있음
<로컬 DNS 서버>
서버들의 계층구조에 엄격하게 속하지는 않음
ISP들은 로컬 DNS 서버를 갖는다 = aka default name server
호스트가 ISP에 연결될 때, 그 ISP는 로컬 DNS 서버로부터 IP주소를 호스트에게 제공
호스트가 DNS 질의를 보내면, 이 질의는 먼저 (프록시로 동작하는) 로컬 DNS 서버에게 전달되고, 그 로컬 DNS 서버는 이 질의를 DNS 서버 계층으로 전달함








재귀적 질의(recursive query)










반복적 질의(iterative query)
<DNS 캐싱> 질의 사슬에서 DNS 서버가 DNS 응답을 받았을 때, 그것은 로컬 메모리에 응답에 대한 정보를 저장할 수 있음, 호스트 네임과 아이피 주소가 쌍으로 저장됨, 호스트 DNS와 IP주소 사이의 매핑과 호스트는 영구적인 것이 아니기 때문에 DNS 서버는 어떤 기간 이후에 저장된 정보를 삭제, 캐시의 내용은 최신 정보가 아닐 수 있음
<DNS 레코드와 메시지>
DNS 서버들은 호스트 네임을 IP주소로 매핑하기 위한 자원 레코드(resource record,RR)를 저장
DNS는 하나 이상의 자원 레코드를 가진 메시지로 응답
(Name, Value, Type, TTL) 4개의 필드를 포함하는 튜플
TTL = 자원 레코드의 생존기간
Type = A) Name=호스트 네임, Value=호스트 네임에 대한 IP주소
Type = NS) Name=도메인, Value=도메인 내부의 호스트에 대한 IP주소를 얻을 수 있는
                                방법을 아는 책임 DNS 서버의 호스트 네임
Type = CNAME) Value = 별칭 호스트 네임 Name에 대한 정식 호스트 네임
Type = MX) Value = 별칭 호스트 Name을 갖는 메일 서버의 정식 호스트 네임
2.5 P2P 파일 분배
항상 켜져 있는 기반구조 서버에 최소한으로 의존, 대신 간헐적으로 연결되는 호스트 쌍들(피어)이 서로 직접 통신
<분배 시간>
서버의 접속 링크 업로드 속도: us
i번째 피어의 접속 링크 업로드 속도와 다운로드 속도: ui di
분배되는 파일 크기 = F
파일의 복사본을 얻고자 하는 피어들의 수 N
클라이언트-서버 구조의 경우에 대한 분배 시간











P2P구조에 대한 최소 분배 시간









<비트 토렌트>
토렌트 = 파일의 분배에 참여하는 모든 피어들의 모임
일반적으로 256kb의 chunk를 다운로드/업로드함
Tracker: 토렌트에 참여하는 피어들을 추적
트랙커가 50개 피어들의 IP 주소를 앨리스에게 보내고 앨리스는 이 리스트에 있는 모든 피어들과 동시에 TCP 연결을 설정  성공적으로 연결한 피어 = 이웃 피어
임의의 주어진 시간에 각 피어는 파일 청크들의 일부를 갖고 있으며, 서로 다른 피어들은 다른 부분을 갖고 있음  앨리스는 이웃 피어들에게 청크 리스트를 요구  갖고 있지 않은 것 요구
①이웃으로부터 어느 청크를 먼저 요구할 것인가?
가장 드문 것 먼저 = 각 청크의 복사본 수가 동일하게 됨
②이웃들 중 어느 피어에게 청크를 요청? = Tit for Tat
가장 빠른 속도로 자신에게 데이터를 제공하는 이웃에게 우선순위를 줌
계속해서 비트 수신 속도를 측정하고 가장 빠르게 전송하는 4개의 피어들을 결정
매 10초마다 재계산하여 4개의 피어 집합을 수정 = 활성화(unchoked)
매 30초마다 임의로 하나의 피어를 추가로 선택하여 청크를 보냄
= 30초마다 앨리스는 임의로 새로운 파트너를 선택하고 교역을 시작
= 피어 중 누구 하나가 더 좋은 파트너를 만날 때가지 서로와 교역을 계속함
Unchoked peer = 4개의 피어 집합과 1개의 탐색 피어
Choked peer = 그 이외의 모든 이웃 피어





2.6.1 인터넷 비디오
비디오 = 이미지의 연속, 초당 24개 또는 30개의 이미지로 일정한 속도로 표시
디지털 이미지 = 픽셀 단위로 구성, 각 픽셀은 휘도와 색상을 나타내는 여러 비트들
Coding: 압축될 수 있음 = 중복되는 픽셀들을 줄이려고
①Spatial coding: N개의 같은 색깔 값을 보내기 보다 색깔 값과 반복 횟수만 보냄
②Temporal coding: i+1 자체를 보내기 보다 i에서 바뀐 부분만 보냄
CBR(constant bit rate): video encoding rate fixed
VBR(variable bit rate): encoding rate changes as amount of spatial, temporal coding changes
2.6.2 HTTP 스트리밍 및 대쉬
HTTP스트리밍의 문제점: 모든 클라이언트들이 그들 사이의 가용 대역폭의 차이에도 불구하고 똑같이 인코딩된 비디오를 전송받음
DASH = Dynamic, Adaptive Streaming over HTTP
비디오는 여러 개의 서로 다른 버전으로 인코딩되며, 각 버전은 서로 다른 비트율과 품질 수준을 갖고 있음. 클라이언트는 동적으로 서로 다른 버전의 비디오를 몇 초 분량의 길이를 가지는 비디오 조각(chunk)단위로 요청. 가용 대역폭 ↑/↓  높/낮은 비트율의 비디오 버전 요청
DASH를 사용할 때, 각 비디오 버전은 HTTP 서버에 서로 다른 URL을 가지고 저장된다.
HTTP 서버는 비트율에 따른 각 버전의 URL을 제공하는 manifest file을 갖고 있다
이후 클라이언트는 매번 원하는 버전의 비디오 chunk를 택하여 HTTP GET 요청 메시지에 URL과 byte-range를 지정하여 요청함
다운로드하는 동안에 클라이언트는 측정된 수신 대역폭과 비트율 결정 알고리즘을 이용해 다음에 선택할 chunk 버전을 결정함 = 클라이언트가 서로 다른 품질 수준을 자유롭게 변화 가능
When to request chunk, what encoding rate to request, where to request chunk
2.6.3 콘텐츠 분배 네트워크(CDN)
현 문제: 엄청난 스트리밍 트래픽을 전 세계에 걸친 지점에 끊김 없이 안정적으로 제공하는 것
<Option1: 단일한 거대 데이터 센터를 구축>
①클라이언트가 데이터 센터로부터 지역적으로 먼 지점에 있는 경우 = 종단 간 처리율 낮아짐
②인기 있는 비디오는 같은 통신링크를 통해 여러 번 반복적으로 전송 될 것 = 대역폭 낭비
③한 번의 장애로 인해 전체 서비스가 중단될 수 있음
<Option2: CDN_다수의 지점에 분산된 서버들을 운영, 데이터의 복사본을 이들에 저장>
①Enter Deep: 서버클러스터를 세계 곳곳의 접속 네트워크에 구축
=서버를 최대한 사용자 가까이에 위치시켜 사용자와 CDN 서버 사이의 링크 및 라우터 수를 줄이고, 사용자가 경험하는 지연시간 및 처리율을 향상 But, 고도로 분산된 설계=유지관리 비용↑
②Bring Home: 보다 적은 수의 핵심 지점에 서버클러스터를 구축하여 ISP를 Home으로 가져옴
=CDN들은 접속 ISP에 연결하는 대신, IXP에 배치 = 유지관리 비용↓ But, 지연시간,처리율 ↓
<CDN 동작>
사용자 호스트의 웹 브라우저가 URL을 지정함으로써 특정 비디오의 재생을 요청하면 CDN은 그 요청을 가로채 ①그 시점에서 클라이언트에게 가장 적당한 CDN 클러스터 선택
              ②클라이언트의 요청을 해당 클러스터의 서버로 연결









2.6.4 사례연구: 넷플릭스
아마존 클라우드
①콘텐츠 수집 = 영화를 아마존 클라우드 시스템의 호스트에 업로드
②콘텐츠 처리 = 다양한 기기사양에 맞게 여러 가지 형식의 비디오를 생성
   DASH를 이용한 HTTP 스트리밍 서비스를 위해 각 형식별로 다양한 비트율의 여러 가지 버전
③CDN으로의 버전 업로드 = 위를 거치면 아.클. 시스템의 호스트는 이들을 CDN으로 업로드







2.7 소켓 프로그래밍
클라이언트-서버 애플리케이션 / 개인의 독점적인 네트워크 애플리케이션
<UDP를 이용한 소켓 프로그래밍>
UDP: 비연결형, 비신뢰적 전송, 독립적인 패킷인 데이터그램 전송
송신 프로세스는 패킷에 목적지 주소를 붙여서 라우트함
수신 프로세스는 소켓을 통해 그 패킷을 추출하고 패킷의 콘텐츠를 조사함
목적지 주소 = 목적지 호스트의 IP주소가 일부가 됨,
              목적지 호스트 내의 특정한 소켓을 식별할 필요가 있음  
              소켓이 생성될 때 포트 번호라고 하는 식별자가 소켓에 할당
결론: 목적지 호스트의 IP주소 + 소켓의 포트 번호 + 송신자의 소스 주소(소스 IP, 소스 소켓)
